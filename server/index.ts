import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { hybridAIService, HybridAIRequest } from './services/hybridAIService';

// ç’°å¢ƒå¤‰æ•°ã‚’èª­ã¿è¾¼ã¿
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// ãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±ã‚’è§£æã™ã‚‹é–¢æ•°
function analyzeRequest(req: express.Request) {
  const ip = req.ip || req.connection.remoteAddress || '127.0.0.1';
  const userAgent = req.get('User-Agent') || '';
  
  // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¢ã‚¯ã‚»ã‚¹ã®åˆ¤å®š
  const isLocal = ip === '127.0.0.1' || 
                  ip === '::1' || 
                  ip.startsWith('192.168.') || 
                  ip.startsWith('10.') || 
                  ip.startsWith('172.');

  return {
    ip,
    userAgent,
    isLocal
  };
}

// Middleware - å‹•çš„CORSè¨­å®šï¼ˆWSL/Docker/ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç’°å¢ƒã«å®Œå…¨å¯¾å¿œï¼‰
app.use(cors({
  origin: function (origin, callback) {
    // é–‹ç™ºç’°å¢ƒã§ã¯å…¨ã¦ã®originã‚’è¨±å¯ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ç·©ãã™ã‚‹ï¼‰
    if (!origin) return callback(null, true);
    
    // è¨±å¯ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³
    const allowedPatterns = [
      /^http:\/\/localhost:\d+$/,
      /^http:\/\/127\.0\.0\.1:\d+$/,
      /^http:\/\/0\.0\.0\.0:\d+$/,
      /^http:\/\/\d+\.\d+\.\d+\.\d+:\d+$/,  // ä»»æ„ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹
      /^http:\/\/.*\.local:\d+$/,            // .localãƒ‰ãƒ¡ã‚¤ãƒ³
    ];
    
    const isAllowed = allowedPatterns.some(pattern => pattern.test(origin));
    console.log(`CORS check: ${origin} -> ${isAllowed ? 'ALLOWED' : 'BLOCKED'}`);
    
    if (isAllowed) {
      callback(null, true);
    } else {
      console.warn(`CORS blocked origin: ${origin}`);
      callback(null, true); // é–‹ç™ºç’°å¢ƒã§ã¯è­¦å‘Šã®ã¿
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// ãƒ—ãƒªãƒ•ãƒ©ã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆå¯¾å¿œ
app.options('*', cors());

// è¿½åŠ ã®ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®šï¼ˆWSLç’°å¢ƒå¯¾å¿œï¼‰
app.use((req, res, next) => {
  // WSLç’°å¢ƒã§ã®ã‚¯ãƒ­ã‚¹ã‚ªãƒªã‚¸ãƒ³ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯
  const origin = req.headers.origin;
  if (origin) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  next();
});

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Health check
app.get('/api/health', (req, res) => {
  const requestInfo = analyzeRequest(req);
  const aiHealth = hybridAIService.getHealthStatus();
  
  res.json({ 
    status: 'ok', 
    message: 'Hybrid AI Chat Server is running',
    ai: {
      ...aiHealth,
      currentProvider: hybridAIService.selectOptimalProvider({
        message: 'test',
        requestInfo
      } as HybridAIRequest),
      selectionMode: 'auto'
    },
    requestInfo,
    capabilities: {
      chat: true,
      codeExecution: true,
      fileOperations: true,
      projectAnalysis: true,
      hybridAI: true
    }
  });
});

// Hybrid AI Chat endpoint
app.post('/api/ai/chat', async (req, res) => {
  console.log('=== Hybrid AI Chat Request Debug ===');
  console.log('Request Body:', JSON.stringify(req.body, null, 2));
  
  try {
    const { message, systemPrompt, context, preferredProvider } = req.body;

    if (!message) {
      console.error('No message provided');
      return res.status(400).json({ error: 'Message is required' });
    }

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±ã‚’åˆ†æ
    const requestInfo = analyzeRequest(req);
    console.log('Request Info:', requestInfo);

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ§‹ç¯‰
    const hybridRequest: HybridAIRequest = {
      message,
      systemPrompt,
      context,
      preferredProvider,
      requestInfo
    };

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIã‚µãƒ¼ãƒ“ã‚¹ã§å‡¦ç†
    const result = await hybridAIService.processRequest(hybridRequest);
    
    console.log(`âœ… Response generated by: ${result.provider} (${result.mode})`);
    
    res.json(result);

  } catch (error) {
    console.error('Hybrid AI Chat error:', error);
    
    res.status(500).json({ 
      error: 'Internal server error',
      details: error.message,
      provider: 'error'
    });
  }
});

// AI File operations
app.post('/api/ai/file-operation', async (req, res) => {
  try {
    const { operation, filePath, content } = req.body;

    let query = '';

    switch (operation) {
      case 'read':
        query = `Read the file: ${filePath}`;
        break;
      case 'write':
        query = `Create or update the file ${filePath} with the following content:\n${content}`;
        break;
      case 'analyze':
        query = `Analyze the file: ${filePath} and provide insights`;
        break;
      default:
        return res.status(400).json({ error: 'Invalid operation' });
    }

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±ã‚’åˆ†æ
    const requestInfo = analyzeRequest(req);

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ§‹ç¯‰
    const hybridRequest: HybridAIRequest = {
      message: query,
      systemPrompt: `You are a helpful file operations assistant. Handle ${operation} operations efficiently.`,
      context: { operation, filePath, tools: operation === 'read' ? ['Read'] : operation === 'write' ? ['Write'] : ['Read', 'Grep'] },
      requestInfo
    };

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIã‚µãƒ¼ãƒ“ã‚¹ã§å‡¦ç†
    const result = await hybridAIService.processRequest(hybridRequest);

    res.json({ 
      result: result.response,
      operation,
      filePath,
      provider: result.provider,
      timestamp: result.timestamp
    });

  } catch (error) {
    console.error('File operation error:', error);
    res.status(500).json({ 
      error: 'File operation failed',
      details: error.message
    });
  }
});

// AI Code analysis
app.post('/api/ai/analyze-project', async (req, res) => {
  try {
    const { query: userQuery, directory = process.cwd() } = req.body;

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±ã‚’åˆ†æ
    const requestInfo = analyzeRequest(req);

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ§‹ç¯‰
    const hybridRequest: HybridAIRequest = {
      message: userQuery || 'Analyze this project structure and provide insights',
      systemPrompt: `You are an expert code analyzer. Analyze the project structure and provide detailed insights about code quality, architecture, and potential improvements.`,
      context: { 
        operation: 'project-analysis',
        directory,
        tools: ['Read', 'Grep', 'Glob', 'Find']
      },
      requestInfo
    };

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIã‚µãƒ¼ãƒ“ã‚¹ã§å‡¦ç†
    const result = await hybridAIService.processRequest(hybridRequest);

    res.json({ 
      analysis: result.response,
      directory,
      provider: result.provider,
      timestamp: result.timestamp
    });

  } catch (error) {
    console.error('Project analysis error:', error);
    res.status(500).json({ 
      error: 'Project analysis failed',
      details: error.message
    });
  }
});

// AI Code execution for C# exercises - COMPLETELY REWRITTEN
app.post('/api/ai/execute-code', async (req, res) => {
  console.log('=== Code Execution Request Debug ===');
  console.log('Request Body:', JSON.stringify(req.body, null, 2));
  
  try {
    const { code, language = 'csharp', options = {}, expectedOutput } = req.body;

    if (!code || code.trim() === '') {
      console.log('No code provided');
      return res.json({
        output: '',
        error: 'ã‚³ãƒ¼ãƒ‰ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚',
        executionTime: 0,
        isSuccess: false,
        memoryUsage: 0,
        timestamp: new Date().toISOString(),
        mode: 'csharp-execution'
      });
    }

    console.log('Executing C# code:', code);
    console.log('Expected output:', expectedOutput);

    // C#å°‚ç”¨ã‚³ãƒ¼ãƒ‰å®Ÿè¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ - å®Œå…¨æ›¸ãç›´ã—
    if (language === 'csharp') {
      
      // Step 1: åŸºæœ¬æ§‹é€ ãƒã‚§ãƒƒã‚¯
      const hasBasicStructure = 
        code.includes('using System') &&
        code.includes('namespace') &&
        code.includes('class') &&
        code.includes('Main');
      
      if (!hasBasicStructure) {
        console.log('Missing basic C# structure');
        return res.json({
          output: '',
          error: 'C#ã®åŸºæœ¬æ§‹é€ ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚using Systemã€namespaceã€classã€Mainãƒ¡ã‚½ãƒƒãƒ‰ãŒå¿…è¦ã§ã™ã€‚',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 2: ç„¡æ„å‘³ãªã‚³ãƒ¼ãƒ‰ã®æ¤œå‡º
      const meaninglessPatterns = [
        /^\s*aaa\s*$/m,
        /^\s*aaaa\s*$/m,
        /^\s*ã‚ã‚ã‚ã‚\s*$/m,
        /^\s*test\s*$/m,
        /^\s*ï½ƒ\s*$/m,
        /^\s*[a-zA-Z]{1,5}\s*$/m
      ];
      
      const mainBody = extractMainMethodBody(code);
      console.log('Main method body:', mainBody);
      
      if (meaninglessPatterns.some(pattern => pattern.test(mainBody))) {
        console.log('Meaningless code detected in Main method');
        return res.json({
          output: '',
          error: 'C#ã®æœ‰åŠ¹ãªã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚å˜ç´”ãªæ–‡å­—åˆ—ã ã‘ã§ã¯å®Ÿè¡Œã§ãã¾ã›ã‚“ã€‚',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 3: Console.WriteLineã®æ­£ç¢ºãªæ¤œè¨¼
      const consoleWriteLinePattern = /Console\.WriteLine\s*\(\s*"([^"]*)"\s*\)\s*;/g;
      const matches = [...code.matchAll(consoleWriteLinePattern)];
      
      console.log('Console.WriteLine matches found:', matches.length);
      
      // Console.WriteLineãŒã‚ã‚‹ã®ã«æ­£ã—ãæ›¸ã‹ã‚Œã¦ã„ãªã„å ´åˆ
      if (code.includes('Console.WriteLine') && matches.length === 0) {
        
        // ã‚»ãƒŸã‚³ãƒ­ãƒ³ãŒãªã„
        const noSemicolonPattern = /Console\.WriteLine\s*\([^)]*\)\s*(?![;])/;
        if (noSemicolonPattern.test(code)) {
          console.log('Missing semicolon after Console.WriteLine');
          return res.json({
            output: '',
            error: 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: Console.WriteLineã®å¾Œã«ã‚»ãƒŸã‚³ãƒ­ãƒ³(;)ãŒå¿…è¦ã§ã™ã€‚',
            executionTime: 0,
            isSuccess: false,
            memoryUsage: 0,
            timestamp: new Date().toISOString(),
            mode: 'csharp-execution'
          });
        }
        
        // ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆãŒé–‰ã˜ã¦ã„ãªã„
        const unclosedQuotePattern = /Console\.WriteLine\s*\(\s*"[^"]*(?!")[\s\S]*$/;
        if (unclosedQuotePattern.test(code)) {
          console.log('Unclosed string in Console.WriteLine');
          return res.json({
            output: '',
            error: 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: æ–‡å­—åˆ—ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ(")ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚',
            executionTime: 0,
            isSuccess: false,
            memoryUsage: 0,
            timestamp: new Date().toISOString(),
            mode: 'csharp-execution'
          });
        }
        
        // ãã®ä»–ã®æ§‹æ–‡ã‚¨ãƒ©ãƒ¼
        console.log('Console.WriteLine syntax error');
        return res.json({
          output: '',
          error: 'Console.WriteLineãŒæ­£ã—ãè¨˜è¿°ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æ­£ã—ã„å½¢å¼: Console.WriteLine("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸");',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 4: æœ‰åŠ¹ãªConsole.WriteLineãŒç„¡ã„å ´åˆ
      if (matches.length === 0) {
        console.log('No valid Console.WriteLine found');
        return res.json({
          output: '',
          error: 'Console.WriteLineã‚’ä½¿ç”¨ã—ã¦ä½•ã‹ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 5: æ­£å¸¸ãªå®Ÿè¡Œ - å‡ºåŠ›ã‚’åé›†
      const output = matches.map(match => match[1]).join('\n');
      console.log('Execution successful, output:', output);
      
      // Step 6: æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ã¨ã®æ¯”è¼ƒï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
      let success = true;
      if (expectedOutput && output !== expectedOutput) {
        success = false;
        console.log('Output mismatch - expected:', expectedOutput, 'actual:', output);
      }
      
      return res.json({
        output,
        error: '',
        executionTime: Math.floor(Math.random() * 100) + 50,
        isSuccess: success,
        memoryUsage: Math.floor(Math.random() * 1024) + 512,
        timestamp: new Date().toISOString(),
        mode: 'csharp-execution'
      });
    }

    // ä»–ã®è¨€èªã¯æœªå¯¾å¿œ
    return res.status(400).json({ 
      error: 'Unsupported language. Only C# is supported.',
      language 
    });

  } catch (error) {
    console.error('Code execution error:', error);
    res.status(500).json({ 
      error: 'Code execution failed',
      details: error.message
    });
  }
});

// AI Code generation
app.post('/api/ai/generate-code', async (req, res) => {
  try {
    const { prompt, fileType = 'tsx', style = 'modern' } = req.body;

    const codeQuery = `Generate ${fileType} code for: ${prompt}. 
    Use ${style} style and best practices. 
    Include proper TypeScript types and error handling.`;

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±ã‚’åˆ†æ
    const requestInfo = analyzeRequest(req);

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ§‹ç¯‰
    const hybridRequest: HybridAIRequest = {
      message: codeQuery,
      systemPrompt: `You are an expert software developer. Generate clean, well-documented ${fileType} code following ${style} best practices.`,
      context: { 
        operation: 'code-generation',
        fileType,
        style
      },
      requestInfo
    };

    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰AIã‚µãƒ¼ãƒ“ã‚¹ã§å‡¦ç†
    const result = await hybridAIService.processRequest(hybridRequest);

    res.json({ 
      code: result.response,
      fileType,
      style,
      provider: result.provider,
      timestamp: result.timestamp
    });

  } catch (error) {
    console.error('Code generation error:', error);
    res.status(500).json({ 
      error: 'Code generation failed',
      details: error.message
    });
  }
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`ğŸš€ Claude Code SDK Server running on http://0.0.0.0:${PORT}`);
  console.log(`ğŸŒ Access from network: http://[YOUR_IP]:${PORT}`);
  console.log(`ğŸ“‹ API endpoints:`);
  console.log(`   GET  /api/health`);
  console.log(`   POST /api/ai/chat`);
  console.log(`   POST /api/ai/execute-code`);
  console.log(`   POST /api/ai/file-operation`);
  console.log(`   POST /api/ai/analyze-project`);
  console.log(`   POST /api/ai/generate-code`);
  console.log(`\nğŸ”§ Make sure you have Claude CLI installed and authenticated:`);
  console.log(`   npm install -g @anthropic-ai/claude-code`);
  console.log(`   claude login`);
});

// C# æ§‹æ–‡æ¤œè¨¼é–¢æ•°
function validateCSharpSyntax(code: string): { valid: boolean; error?: string } {
  console.log('Validating C# syntax...');
  
  // 1. æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®ãƒã‚§ãƒƒã‚¯
  const lines = code.split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    let inString = false;
    let escapeNext = false;
    
    for (let j = 0; j < line.length; j++) {
      const char = line[j];
      
      if (escapeNext) {
        escapeNext = false;
        continue;
      }
      
      if (char === '\\') {
        escapeNext = true;
        continue;
      }
      
      if (char === '"') {
        inString = !inString;
      }
    }
    
    // è¡Œæœ«ã§æ–‡å­—åˆ—ãŒé–‹ã„ãŸã¾ã¾ã®å ´åˆ
    if (inString) {
      return {
        valid: false,
        error: `æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: ${i + 1}è¡Œç›® - æ–‡å­—åˆ—ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ(")ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚`
      };
    }
  }
  
  // 2. Console.WriteLineã®å¾Œã®ã‚»ãƒŸã‚³ãƒ­ãƒ³ãƒã‚§ãƒƒã‚¯
  const consoleWriteLinePattern = /Console\.WriteLine\s*\([^)]*\)/g;
  let match;
  while ((match = consoleWriteLinePattern.exec(code)) !== null) {
    const startIndex = match.index;
    const endIndex = startIndex + match[0].length;
    
    // ãƒãƒƒãƒã—ãŸä½ç½®ã‹ã‚‰è¡Œç•ªå·ã‚’è¨ˆç®—
    const beforeMatch = code.substring(0, startIndex);
    const lineNumber = beforeMatch.split('\n').length;
    
    // ãƒãƒƒãƒã—ãŸéƒ¨åˆ†ã®å¾Œã‚’ãƒã‚§ãƒƒã‚¯
    const afterMatch = code.substring(endIndex).trimStart();
    if (!afterMatch.startsWith(';')) {
      return {
        valid: false,
        error: `æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: ${lineNumber}è¡Œç›® - Console.WriteLineã®å¾Œã«ã‚»ãƒŸã‚³ãƒ­ãƒ³(;)ãŒå¿…è¦ã§ã™ã€‚`
      };
    }
  }
  
  // 3. æ‹¬å¼§ã®ãƒãƒ©ãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯
  const brackets = { '(': 0, '{': 0, '[': 0 };
  let inString = false;
  let escapeNext = false;
  
  for (const char of code) {
    if (escapeNext) {
      escapeNext = false;
      continue;
    }
    
    if (char === '\\' && inString) {
      escapeNext = true;
      continue;
    }
    
    if (char === '"') {
      inString = !inString;
      continue;
    }
    
    if (!inString) {
      if (char === '(') brackets['(']++;
      if (char === ')') brackets['(']--;
      if (char === '{') brackets['{']++;
      if (char === '}') brackets['{']--;
      if (char === '[') brackets['[']++;
      if (char === ']') brackets['[']--;
    }
  }
  
  if (brackets['('] !== 0) {
    return {
      valid: false,
      error: 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: ä¸¸æ‹¬å¼§()ãŒæ­£ã—ãé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'
    };
  }
  
  if (brackets['{'] !== 0) {
    return {
      valid: false,
      error: 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: ä¸­æ‹¬å¼§{}ãŒæ­£ã—ãé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'
    };
  }
  
  if (brackets['['] !== 0) {
    return {
      valid: false,
      error: 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: è§’æ‹¬å¼§[]ãŒæ­£ã—ãé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'
    };
  }
  
  console.log('Syntax validation passed');
  return { valid: true };
}

// ã‚³ãƒ¼ãƒ‰æ§‹é€ ã®æ¤œè¨¼
function validateCodeStructure(code: string): { valid: boolean; error?: string } {
  console.log('Validating code structure...');
  
  // å¿…é ˆè¦ç´ ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆå†…ã¯é™¤å¤–ï¼‰
  const codeWithoutComments = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
  
  if (!codeWithoutComments.includes('using System')) {
    return {
      valid: false,
      error: 'using System; ãƒ‡ã‚£ãƒ¬ã‚¯ãƒ†ã‚£ãƒ–ãŒå¿…è¦ã§ã™ã€‚'
    };
  }
  
  if (!codeWithoutComments.includes('namespace')) {
    return {
      valid: false,
      error: 'namespace ã®å®£è¨€ãŒå¿…è¦ã§ã™ã€‚'
    };
  }
  
  if (!codeWithoutComments.includes('class')) {
    return {
      valid: false,
      error: 'class ã®å®£è¨€ãŒå¿…è¦ã§ã™ã€‚'
    };
  }
  
  if (!codeWithoutComments.includes('static void Main')) {
    return {
      valid: false,
      error: 'static void Main ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¿…è¦ã§ã™ã€‚'
    };
  }
  
  console.log('Structure validation passed');
  return { valid: true };
}

// æ­£ç¢ºãªConsole.WriteLineå‡ºåŠ›ã®æŠ½å‡º
function extractConsoleOutputs(code: string): string[] {
  console.log('Extracting console outputs...');
  
  const outputs: string[] = [];
  
  // æ­£ç¢ºãªæ§‹æ–‡ã®Console.WriteLineã®ã¿ã‚’ãƒãƒƒãƒï¼ˆã‚»ãƒŸã‚³ãƒ­ãƒ³ä»˜ãï¼‰
  const pattern = /Console\.WriteLine\s*\(\s*"([^"]*)"\s*\)\s*;/g;
  let match;
  
  while ((match = pattern.exec(code)) !== null) {
    outputs.push(match[1]);
  }
  
  console.log('Extracted outputs:', outputs);
  return outputs;
}

// Mainãƒ¡ã‚½ãƒƒãƒ‰ã®æœ¬ä½“ã‚’æŠ½å‡º
function extractMainMethodBody(code: string): string {
  // Mainãƒ¡ã‚½ãƒƒãƒ‰ã®æœ¬ä½“ã‚’æŠ½å‡ºã™ã‚‹æ­£è¦è¡¨ç¾
  const mainMethodPattern = /static\s+void\s+Main\s*\([^)]*\)\s*\{([\s\S]*?)\}/;
  const match = code.match(mainMethodPattern);
  
  if (match && match[1]) {
    // ã‚³ãƒ¡ãƒ³ãƒˆã‚’é™¤å»
    let body = match[1];
    body = body.replace(/\/\/.*$/gm, ''); // è¡Œã‚³ãƒ¡ãƒ³ãƒˆ
    body = body.replace(/\/\*[\s\S]*?\*\//g, ''); // ãƒ–ãƒ­ãƒƒã‚¯ã‚³ãƒ¡ãƒ³ãƒˆ
    return body.trim();
  }
  
  return '';
}

export default app; 