import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { hybridAIService, HybridAIRequest } from './services/hybridAIService';

// 環境変数を読み込み
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// リクエスト情報を解析する関数
function analyzeRequest(req: express.Request) {
  const ip = req.ip || req.connection.remoteAddress || '127.0.0.1';
  const userAgent = req.get('User-Agent') || '';
  
  // ローカルアクセスの判定
  const isLocal = ip === '127.0.0.1' || 
                  ip === '::1' || 
                  ip.startsWith('192.168.') || 
                  ip.startsWith('10.') || 
                  ip.startsWith('172.');

  return {
    ip,
    userAgent,
    isLocal
  };
}

// Middleware - 動的CORS設定（WSL/Docker/ネットワーク環境に完全対応）
app.use(cors({
  origin: function (origin, callback) {
    // 開発環境では全てのoriginを許可（セキュリティを緩くする）
    if (!origin) return callback(null, true);
    
    // 許可するパターン
    const allowedPatterns = [
      /^http:\/\/localhost:\d+$/,
      /^http:\/\/127\.0\.0\.1:\d+$/,
      /^http:\/\/0\.0\.0\.0:\d+$/,
      /^http:\/\/\d+\.\d+\.\d+\.\d+:\d+$/,  // 任意のIPアドレス
      /^http:\/\/.*\.local:\d+$/,            // .localドメイン
    ];
    
    const isAllowed = allowedPatterns.some(pattern => pattern.test(origin));
    console.log(`CORS check: ${origin} -> ${isAllowed ? 'ALLOWED' : 'BLOCKED'}`);
    
    if (isAllowed) {
      callback(null, true);
    } else {
      console.warn(`CORS blocked origin: ${origin}`);
      callback(null, true); // 開発環境では警告のみ
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// プリフライトリクエスト対応
app.options('*', cors());

// 追加のヘッダー設定（WSL環境対応）
app.use((req, res, next) => {
  // WSL環境でのクロスオリジンアクセスを許可
  const origin = req.headers.origin;
  if (origin) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  next();
});

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Health check
app.get('/api/health', (req, res) => {
  const requestInfo = analyzeRequest(req);
  const aiHealth = hybridAIService.getHealthStatus();
  
  res.json({ 
    status: 'ok', 
    message: 'Hybrid AI Chat Server is running',
    ai: {
      ...aiHealth,
      currentProvider: hybridAIService.selectOptimalProvider({
        message: 'test',
        requestInfo
      } as HybridAIRequest),
      selectionMode: 'auto'
    },
    requestInfo,
    capabilities: {
      chat: true,
      codeExecution: true,
      fileOperations: true,
      projectAnalysis: true,
      hybridAI: true
    }
  });
});

// Hybrid AI Chat endpoint
app.post('/api/ai/chat', async (req, res) => {
  console.log('=== Hybrid AI Chat Request Debug ===');
  console.log('Request Body:', JSON.stringify(req.body, null, 2));
  
  try {
    const { message, systemPrompt, context, preferredProvider } = req.body;

    if (!message) {
      console.error('No message provided');
      return res.status(400).json({ error: 'Message is required' });
    }

    // リクエスト情報を分析
    const requestInfo = analyzeRequest(req);
    console.log('Request Info:', requestInfo);

    // ハイブリッドAIリクエストを構築
    const hybridRequest: HybridAIRequest = {
      message,
      systemPrompt,
      context,
      preferredProvider,
      requestInfo
    };

    // ハイブリッドAIサービスで処理
    const result = await hybridAIService.processRequest(hybridRequest);
    
    console.log(`✅ Response generated by: ${result.provider} (${result.mode})`);
    
    res.json(result);

  } catch (error) {
    console.error('Hybrid AI Chat error:', error);
    
    res.status(500).json({ 
      error: 'Internal server error',
      details: error.message,
      provider: 'error'
    });
  }
});

// AI File operations
app.post('/api/ai/file-operation', async (req, res) => {
  try {
    const { operation, filePath, content } = req.body;

    let query = '';

    switch (operation) {
      case 'read':
        query = `Read the file: ${filePath}`;
        break;
      case 'write':
        query = `Create or update the file ${filePath} with the following content:\n${content}`;
        break;
      case 'analyze':
        query = `Analyze the file: ${filePath} and provide insights`;
        break;
      default:
        return res.status(400).json({ error: 'Invalid operation' });
    }

    // リクエスト情報を分析
    const requestInfo = analyzeRequest(req);

    // ハイブリッドAIリクエストを構築
    const hybridRequest: HybridAIRequest = {
      message: query,
      systemPrompt: `You are a helpful file operations assistant. Handle ${operation} operations efficiently.`,
      context: { operation, filePath, tools: operation === 'read' ? ['Read'] : operation === 'write' ? ['Write'] : ['Read', 'Grep'] },
      requestInfo
    };

    // ハイブリッドAIサービスで処理
    const result = await hybridAIService.processRequest(hybridRequest);

    res.json({ 
      result: result.response,
      operation,
      filePath,
      provider: result.provider,
      timestamp: result.timestamp
    });

  } catch (error) {
    console.error('File operation error:', error);
    res.status(500).json({ 
      error: 'File operation failed',
      details: error.message
    });
  }
});

// AI Code analysis
app.post('/api/ai/analyze-project', async (req, res) => {
  try {
    const { query: userQuery, directory = process.cwd() } = req.body;

    // リクエスト情報を分析
    const requestInfo = analyzeRequest(req);

    // ハイブリッドAIリクエストを構築
    const hybridRequest: HybridAIRequest = {
      message: userQuery || 'Analyze this project structure and provide insights',
      systemPrompt: `You are an expert code analyzer. Analyze the project structure and provide detailed insights about code quality, architecture, and potential improvements.`,
      context: { 
        operation: 'project-analysis',
        directory,
        tools: ['Read', 'Grep', 'Glob', 'Find']
      },
      requestInfo
    };

    // ハイブリッドAIサービスで処理
    const result = await hybridAIService.processRequest(hybridRequest);

    res.json({ 
      analysis: result.response,
      directory,
      provider: result.provider,
      timestamp: result.timestamp
    });

  } catch (error) {
    console.error('Project analysis error:', error);
    res.status(500).json({ 
      error: 'Project analysis failed',
      details: error.message
    });
  }
});

// AI Code execution for C# exercises - COMPLETELY REWRITTEN
app.post('/api/ai/execute-code', async (req, res) => {
  console.log('=== Code Execution Request Debug ===');
  console.log('Request Body:', JSON.stringify(req.body, null, 2));
  
  try {
    const { code, language = 'csharp', options = {}, expectedOutput } = req.body;

    if (!code || code.trim() === '') {
      console.log('No code provided');
      return res.json({
        output: '',
        error: 'コードが入力されていません。',
        executionTime: 0,
        isSuccess: false,
        memoryUsage: 0,
        timestamp: new Date().toISOString(),
        mode: 'csharp-execution'
      });
    }

    console.log('Executing C# code:', code);
    console.log('Expected output:', expectedOutput);

    // C#専用コード実行シミュレーター - 完全書き直し
    if (language === 'csharp') {
      
      // Step 1: 基本構造チェック
      const hasBasicStructure = 
        code.includes('using System') &&
        code.includes('namespace') &&
        code.includes('class') &&
        code.includes('Main');
      
      if (!hasBasicStructure) {
        console.log('Missing basic C# structure');
        return res.json({
          output: '',
          error: 'C#の基本構造が不足しています。using System、namespace、class、Mainメソッドが必要です。',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 2: 無意味なコードの検出
      const meaninglessPatterns = [
        /^\s*aaa\s*$/m,
        /^\s*aaaa\s*$/m,
        /^\s*ああああ\s*$/m,
        /^\s*test\s*$/m,
        /^\s*ｃ\s*$/m,
        /^\s*[a-zA-Z]{1,5}\s*$/m
      ];
      
      const mainBody = extractMainMethodBody(code);
      console.log('Main method body:', mainBody);
      
      if (meaninglessPatterns.some(pattern => pattern.test(mainBody))) {
        console.log('Meaningless code detected in Main method');
        return res.json({
          output: '',
          error: 'C#の有効なステートメントを記述してください。単純な文字列だけでは実行できません。',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 3: Console.WriteLineの正確な検証
      const consoleWriteLinePattern = /Console\.WriteLine\s*\(\s*"([^"]*)"\s*\)\s*;/g;
      const matches = [...code.matchAll(consoleWriteLinePattern)];
      
      console.log('Console.WriteLine matches found:', matches.length);
      
      // Console.WriteLineがあるのに正しく書かれていない場合
      if (code.includes('Console.WriteLine') && matches.length === 0) {
        
        // セミコロンがない
        const noSemicolonPattern = /Console\.WriteLine\s*\([^)]*\)\s*(?![;])/;
        if (noSemicolonPattern.test(code)) {
          console.log('Missing semicolon after Console.WriteLine');
          return res.json({
            output: '',
            error: '構文エラー: Console.WriteLineの後にセミコロン(;)が必要です。',
            executionTime: 0,
            isSuccess: false,
            memoryUsage: 0,
            timestamp: new Date().toISOString(),
            mode: 'csharp-execution'
          });
        }
        
        // ダブルクォートが閉じていない
        const unclosedQuotePattern = /Console\.WriteLine\s*\(\s*"[^"]*(?!")[\s\S]*$/;
        if (unclosedQuotePattern.test(code)) {
          console.log('Unclosed string in Console.WriteLine');
          return res.json({
            output: '',
            error: '構文エラー: 文字列が閉じられていません。ダブルクォート(")が不足しています。',
            executionTime: 0,
            isSuccess: false,
            memoryUsage: 0,
            timestamp: new Date().toISOString(),
            mode: 'csharp-execution'
          });
        }
        
        // その他の構文エラー
        console.log('Console.WriteLine syntax error');
        return res.json({
          output: '',
          error: 'Console.WriteLineが正しく記述されていません。正しい形式: Console.WriteLine("メッセージ");',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 4: 有効なConsole.WriteLineが無い場合
      if (matches.length === 0) {
        console.log('No valid Console.WriteLine found');
        return res.json({
          output: '',
          error: 'Console.WriteLineを使用して何かを出力してください。',
          executionTime: 0,
          isSuccess: false,
          memoryUsage: 0,
          timestamp: new Date().toISOString(),
          mode: 'csharp-execution'
        });
      }
      
      // Step 5: 正常な実行 - 出力を収集
      const output = matches.map(match => match[1]).join('\n');
      console.log('Execution successful, output:', output);
      
      // Step 6: 期待される出力との比較（オプション）
      let success = true;
      if (expectedOutput && output !== expectedOutput) {
        success = false;
        console.log('Output mismatch - expected:', expectedOutput, 'actual:', output);
      }
      
      return res.json({
        output,
        error: '',
        executionTime: Math.floor(Math.random() * 100) + 50,
        isSuccess: success,
        memoryUsage: Math.floor(Math.random() * 1024) + 512,
        timestamp: new Date().toISOString(),
        mode: 'csharp-execution'
      });
    }

    // 他の言語は未対応
    return res.status(400).json({ 
      error: 'Unsupported language. Only C# is supported.',
      language 
    });

  } catch (error) {
    console.error('Code execution error:', error);
    res.status(500).json({ 
      error: 'Code execution failed',
      details: error.message
    });
  }
});

// AI Code generation
app.post('/api/ai/generate-code', async (req, res) => {
  try {
    const { prompt, fileType = 'tsx', style = 'modern' } = req.body;

    const codeQuery = `Generate ${fileType} code for: ${prompt}. 
    Use ${style} style and best practices. 
    Include proper TypeScript types and error handling.`;

    // リクエスト情報を分析
    const requestInfo = analyzeRequest(req);

    // ハイブリッドAIリクエストを構築
    const hybridRequest: HybridAIRequest = {
      message: codeQuery,
      systemPrompt: `You are an expert software developer. Generate clean, well-documented ${fileType} code following ${style} best practices.`,
      context: { 
        operation: 'code-generation',
        fileType,
        style
      },
      requestInfo
    };

    // ハイブリッドAIサービスで処理
    const result = await hybridAIService.processRequest(hybridRequest);

    res.json({ 
      code: result.response,
      fileType,
      style,
      provider: result.provider,
      timestamp: result.timestamp
    });

  } catch (error) {
    console.error('Code generation error:', error);
    res.status(500).json({ 
      error: 'Code generation failed',
      details: error.message
    });
  }
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`🚀 Claude Code SDK Server running on http://0.0.0.0:${PORT}`);
  console.log(`🌐 Access from network: http://[YOUR_IP]:${PORT}`);
  console.log(`📋 API endpoints:`);
  console.log(`   GET  /api/health`);
  console.log(`   POST /api/ai/chat`);
  console.log(`   POST /api/ai/execute-code`);
  console.log(`   POST /api/ai/file-operation`);
  console.log(`   POST /api/ai/analyze-project`);
  console.log(`   POST /api/ai/generate-code`);
  console.log(`\n🔧 Make sure you have Claude CLI installed and authenticated:`);
  console.log(`   npm install -g @anthropic-ai/claude-code`);
  console.log(`   claude login`);
});

// C# 構文検証関数
function validateCSharpSyntax(code: string): { valid: boolean; error?: string } {
  console.log('Validating C# syntax...');
  
  // 1. 文字列リテラルのチェック
  const lines = code.split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    let inString = false;
    let escapeNext = false;
    
    for (let j = 0; j < line.length; j++) {
      const char = line[j];
      
      if (escapeNext) {
        escapeNext = false;
        continue;
      }
      
      if (char === '\\') {
        escapeNext = true;
        continue;
      }
      
      if (char === '"') {
        inString = !inString;
      }
    }
    
    // 行末で文字列が開いたままの場合
    if (inString) {
      return {
        valid: false,
        error: `構文エラー: ${i + 1}行目 - 文字列が閉じられていません。ダブルクォート(")が不足しています。`
      };
    }
  }
  
  // 2. Console.WriteLineの後のセミコロンチェック
  const consoleWriteLinePattern = /Console\.WriteLine\s*\([^)]*\)/g;
  let match;
  while ((match = consoleWriteLinePattern.exec(code)) !== null) {
    const startIndex = match.index;
    const endIndex = startIndex + match[0].length;
    
    // マッチした位置から行番号を計算
    const beforeMatch = code.substring(0, startIndex);
    const lineNumber = beforeMatch.split('\n').length;
    
    // マッチした部分の後をチェック
    const afterMatch = code.substring(endIndex).trimStart();
    if (!afterMatch.startsWith(';')) {
      return {
        valid: false,
        error: `構文エラー: ${lineNumber}行目 - Console.WriteLineの後にセミコロン(;)が必要です。`
      };
    }
  }
  
  // 3. 括弧のバランスチェック
  const brackets = { '(': 0, '{': 0, '[': 0 };
  let inString = false;
  let escapeNext = false;
  
  for (const char of code) {
    if (escapeNext) {
      escapeNext = false;
      continue;
    }
    
    if (char === '\\' && inString) {
      escapeNext = true;
      continue;
    }
    
    if (char === '"') {
      inString = !inString;
      continue;
    }
    
    if (!inString) {
      if (char === '(') brackets['(']++;
      if (char === ')') brackets['(']--;
      if (char === '{') brackets['{']++;
      if (char === '}') brackets['{']--;
      if (char === '[') brackets['[']++;
      if (char === ']') brackets['[']--;
    }
  }
  
  if (brackets['('] !== 0) {
    return {
      valid: false,
      error: '構文エラー: 丸括弧()が正しく閉じられていません。'
    };
  }
  
  if (brackets['{'] !== 0) {
    return {
      valid: false,
      error: '構文エラー: 中括弧{}が正しく閉じられていません。'
    };
  }
  
  if (brackets['['] !== 0) {
    return {
      valid: false,
      error: '構文エラー: 角括弧[]が正しく閉じられていません。'
    };
  }
  
  console.log('Syntax validation passed');
  return { valid: true };
}

// コード構造の検証
function validateCodeStructure(code: string): { valid: boolean; error?: string } {
  console.log('Validating code structure...');
  
  // 必須要素の存在チェック（コメント内は除外）
  const codeWithoutComments = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
  
  if (!codeWithoutComments.includes('using System')) {
    return {
      valid: false,
      error: 'using System; ディレクティブが必要です。'
    };
  }
  
  if (!codeWithoutComments.includes('namespace')) {
    return {
      valid: false,
      error: 'namespace の宣言が必要です。'
    };
  }
  
  if (!codeWithoutComments.includes('class')) {
    return {
      valid: false,
      error: 'class の宣言が必要です。'
    };
  }
  
  if (!codeWithoutComments.includes('static void Main')) {
    return {
      valid: false,
      error: 'static void Main メソッドが必要です。'
    };
  }
  
  console.log('Structure validation passed');
  return { valid: true };
}

// 正確なConsole.WriteLine出力の抽出
function extractConsoleOutputs(code: string): string[] {
  console.log('Extracting console outputs...');
  
  const outputs: string[] = [];
  
  // 正確な構文のConsole.WriteLineのみをマッチ（セミコロン付き）
  const pattern = /Console\.WriteLine\s*\(\s*"([^"]*)"\s*\)\s*;/g;
  let match;
  
  while ((match = pattern.exec(code)) !== null) {
    outputs.push(match[1]);
  }
  
  console.log('Extracted outputs:', outputs);
  return outputs;
}

// Mainメソッドの本体を抽出
function extractMainMethodBody(code: string): string {
  // Mainメソッドの本体を抽出する正規表現
  const mainMethodPattern = /static\s+void\s+Main\s*\([^)]*\)\s*\{([\s\S]*?)\}/;
  const match = code.match(mainMethodPattern);
  
  if (match && match[1]) {
    // コメントを除去
    let body = match[1];
    body = body.replace(/\/\/.*$/gm, ''); // 行コメント
    body = body.replace(/\/\*[\s\S]*?\*\//g, ''); // ブロックコメント
    return body.trim();
  }
  
  return '';
}

export default app; 